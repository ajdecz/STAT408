id4
abs(stud_resid)[id4] > crit
# From class convo it is clear you wanted linear so I'll do both bc I did class example first
# initial observation
plot(modfull,1) #modfull is y ~ XZ (above)
# obs 11 is an influential observation, 73
rstud <- rstudent(modfull)
id1 <- which.max(abs(rstud))
n <- nrow(X2)
k <- 4
alpha <- 0.01
crit <- qt(1-alpha/2,n-k-1)
(abs(rstud)[id1] > crit)
# observation 73 is our next influential observation
modfull2 <- lm(y[-11,] ~ X2[-11, -1])
rstud2 <- rstudent(modfull2)
id2 <- which.max(abs(rstud2))
abs(rstud2)[id2] > crit
# next one 42 is not an influential observation
infl_obs <- c(11,73)
modfull3 <- lm(y[-infl_obs,] ~ X2[-infl_obs, -1])
rstud3 <- rstudent(modfull3)
id3 <- which.max(abs(rstud3))
abs(rstud3)[id3] > crit
# LINEAR
hat_matrix <- X2 %*% solve(t(X2) %*% X2) %*% t(X2)
yhatx2 <- X2 %*% BX2
errorest <- y - yhatx2
lev <- diag(hat_matrix)
MSEX2 <- SSEX2 / (nrow(X2) - k)
stud_resid <- errorest / sqrt(as.numeric(MSEX2)) * sqrt(1 - lev)
id4 <- which.max(abs(stud_resid))
id4
abs(stud_resid)[id4] > crit
# From class convo it is clear you wanted linear so I'll do both bc I did class example first
# initial observation
plot(modfull,1) #modfull is y ~ XZ (above)
# obs 11 is an influential observation, 73
rstud <- rstudent(modfull)
id1 <- which.max(abs(rstud))
n <- nrow(X2)
k <- 4
alpha <- 0.01
crit <- qt(1-alpha/2,n-k-1)
(abs(rstud)[id1] > crit)
# observation 73 is our next influential observation
modfull2 <- lm(y[-11,] ~ X2[-11, -1])
rstud2 <- rstudent(modfull2)
id2 <- which.max(abs(rstud2))
abs(rstud2)[id2] > crit
# next one 42 is not an influential observation
infl_obs <- c(11,73)
modfull3 <- lm(y[-infl_obs,] ~ X2[-infl_obs, -1])
rstud3 <- rstudent(modfull3)
id3 <- which.max(abs(rstud3))
abs(rstud3)[id3] > crit
# LINEAR
hat_matrix <- X2 %*% solve(t(X2) %*% X2) %*% t(X2)
yhatx2 <- X2 %*% BX2
errorest <- y - yhatx2
lev <- diag(hat_matrix)
MSEX2 <- SSEX2 / (nrow(X2) - k)
stud_resid <- errorest / sqrt(as.numeric(MSEX2)) * sqrt(1 - lev)
# first test
id4 <- which.max(abs(stud_resid))
id4
abs(stud_resid)[id4] > crit
# 11 is true
#second test
stud_resid2 <- stud_resid[-11,]
# From class convo it is clear you wanted linear so I'll do both bc I did class example first
# initial observation
plot(modfull,1) #modfull is y ~ XZ (above)
# obs 11 is an influential observation, 73
rstud <- rstudent(modfull)
id1 <- which.max(abs(rstud))
n <- nrow(X2)
k <- 4
alpha <- 0.01
crit <- qt(1-alpha/2,n-k-1)
(abs(rstud)[id1] > crit)
# observation 73 is our next influential observation
modfull2 <- lm(y[-11,] ~ X2[-11, -1])
rstud2 <- rstudent(modfull2)
id2 <- which.max(abs(rstud2))
abs(rstud2)[id2] > crit
# next one 42 is not an influential observation
infl_obs <- c(11,73)
modfull3 <- lm(y[-infl_obs,] ~ X2[-infl_obs, -1])
rstud3 <- rstudent(modfull3)
id3 <- which.max(abs(rstud3))
abs(rstud3)[id3] > crit
# LINEAR
# first test, 11 is influential
hat_matrix <- X2 %*% solve(t(X2) %*% X2) %*% t(X2)
yhatx2 <- X2 %*% BX2
errorest <- y - yhatx2
lev <- diag(hat_matrix)
MSEX2 <- SSEX2 / (nrow(X2) - k)
stud_resid <- errorest / sqrt(as.numeric(MSEX2)) * sqrt(1 - lev)
id4 <- which.max(abs(stud_resid))
id4
abs(stud_resid)[id4] > crit
# 11 is true
#second test
X2_rm11 <- X2[-11,]
hat_matrix <- X2_rm11 %*% solve(t(X2_rm11) %*% X2_rm11) %*% t(X2_rm11)
yhatx2 <- X2_rm11 %*% BX2
errorest <- y[-11,] - yhatx2
lev <- diag(hat_matrix)
MSEX2 <- SSEX2 / (nrow(X2_rm11) - k)
stud_resid <- errorest / sqrt(as.numeric(MSEX2)) * sqrt(1 - lev)
id5 <- which.max(abs(stud_resid))
id5
abs(stud_resid)[id5] > crit
# From class convo it is clear you wanted linear so I'll do both bc I did class example first
# initial observation
plot(modfull,1) #modfull is y ~ XZ (above)
# obs 11 is an influential observation, 73
rstud <- rstudent(modfull)
id1 <- which.max(abs(rstud))
n <- nrow(X2)
k <- 4
alpha <- 0.01
crit <- qt(1-alpha/2,n-k-1)
(abs(rstud)[id1] > crit)
# observation 73 is our next influential observation
modfull2 <- lm(y[-11,] ~ X2[-11, -1])
rstud2 <- rstudent(modfull2)
id2 <- which.max(abs(rstud2))
abs(rstud2)[id2] > crit
# next one 42 is not an influential observation
infl_obs <- c(11,73)
modfull3 <- lm(y[-infl_obs,] ~ X2[-infl_obs, -1])
rstud3 <- rstudent(modfull3)
id3 <- which.max(abs(rstud3))
abs(rstud3)[id3] > crit
# LINEAR
# first test, 11 is influential
hat_matrix <- X2 %*% solve(t(X2) %*% X2) %*% t(X2)
yhatx2 <- X2 %*% BX2
errorest <- y - yhatx2
lev <- diag(hat_matrix)
MSEX2 <- SSEX2 / (nrow(X2) - k)
stud_resid <- errorest / sqrt(as.numeric(MSEX2)) * sqrt(1 - lev)
id4 <- which.max(abs(stud_resid))
id4
abs(stud_resid)[id4] > crit
# 11 is true
#second test
X2_rm11 <- X2[-11,]
hat_matrix <- X2_rm11 %*% solve(t(X2_rm11) %*% X2_rm11) %*% t(X2_rm11)
yhatx2 <- X2_rm11 %*% BX2
errorest <- y[-11,] - yhatx2
lev <- diag(hat_matrix)
MSEX2 <- SSEX2 / (nrow(X2_rm11) - k)
stud_resid <- errorest / sqrt(as.numeric(MSEX2)) * sqrt(1 - lev)
id5 <- which.max(abs(stud_resid))
id5
abs(stud_resid)[id5] > crit
#third test
inf <- c(11,72)
X2_rm_inf <- X2[-inf,]
hat_matrix <- X2_rm_inf %*% solve(t(X2_rm_inf) %*% X2_rm_inf) %*% t(X2_rm_inf)
yhatx2 <- X2_rm_inf %*% BX2
errorest <- y[-inf] - yhatx2
lev <- diag(hat_matrix)
MSEX2 <- SSEX2 / (nrow(X2_rm_inf) - k)
stud_resid <- errorest / sqrt(as.numeric(MSEX2)) * sqrt(1 - lev)
id6 <- which.max(abs(stud_resid))
id6
abs(stud_resid)[id6] > crit
# From class convo it is clear you wanted linear so I'll do both bc I did class example first
# initial observation
plot(modfull,1) #modfull is y ~ XZ (above)
# obs 11 is an influential observation, 73
rstud <- rstudent(modfull)
id1 <- which.max(abs(rstud))
n <- nrow(X2)
k <- 4
alpha <- 0.01
crit <- qt(1-alpha/2,n-k-1)
(abs(rstud)[id1] > crit)
# observation 73 is our next influential observation
modfull2 <- lm(y[-11,] ~ X2[-11, -1])
rstud2 <- rstudent(modfull2)
id2 <- which.max(abs(rstud2))
abs(rstud2)[id2] > crit
# next one 42 is not an influential observation
infl_obs <- c(11,73)
modfull3 <- lm(y[-infl_obs,] ~ X2[-infl_obs, -1])
rstud3 <- rstudent(modfull3)
id3 <- which.max(abs(rstud3))
abs(rstud3)[id3] > crit
# LINEAR
# first test, 11 is influential
hat_matrix <- X2 %*% solve(t(X2) %*% X2) %*% t(X2)
yhatx2 <- X2 %*% BX2
errorest <- y - yhatx2
lev <- diag(hat_matrix)
MSEX2 <- SSEX2 / (nrow(X2) - k)
stud_resid <- errorest / sqrt(as.numeric(MSEX2)) * sqrt(1 - lev)
id4 <- which.max(abs(stud_resid))
id4
abs(stud_resid)[id4] > crit
# 11 is true
#second test
X2_rm11 <- X2[-11,]
hat_matrix <- X2_rm11 %*% solve(t(X2_rm11) %*% X2_rm11) %*% t(X2_rm11)
yhatx2 <- X2_rm11 %*% BX2
errorest <- y[-11,] - yhatx2
lev <- diag(hat_matrix)
MSEX2 <- SSEX2 / (nrow(X2_rm11) - k)
stud_resid <- errorest / sqrt(as.numeric(MSEX2)) * sqrt(1 - lev)
id5 <- which.max(abs(stud_resid))
id5
abs(stud_resid)[id5] > crit
#third test
inf <- c(11,73)
X2_rm_inf <- X2[-inf,]
hat_matrix <- X2_rm_inf %*% solve(t(X2_rm_inf) %*% X2_rm_inf) %*% t(X2_rm_inf)
yhatx2 <- X2_rm_inf %*% BX2
errorest <- y[-inf] - yhatx2
lev <- diag(hat_matrix)
MSEX2 <- SSEX2 / (nrow(X2_rm_inf) - k)
stud_resid <- errorest / sqrt(as.numeric(MSEX2)) * sqrt(1 - lev)
id6 <- which.max(abs(stud_resid))
id6
abs(stud_resid)[id6] > crit
# From class convo it is clear you wanted linear so I did rstud() method first
# initial observation
plot(modfull,1) #modfull is y ~ XZ (above)
# obs 11 is an influential observation, 73
rstud <- rstudent(modfull)
id1 <- which.max(abs(rstud))
n <- nrow(X2)
k <- 4
alpha <- 0.01
crit <- qt(1-alpha/2,n-k-1)
(abs(rstud)[id1] > crit)
# observation 73 is our next influential observation
modfull2 <- lm(y[-11,] ~ X2[-11, -1])
rstud2 <- rstudent(modfull2)
id2 <- which.max(abs(rstud2))
abs(rstud2)[id2] > crit
# next one 42 is not an influential observation
infl_obs <- c(11,73)
modfull3 <- lm(y[-infl_obs,] ~ X2[-infl_obs, -1])
rstud3 <- rstudent(modfull3)
id3 <- which.max(abs(rstud3))
abs(rstud3)[id3] > crit
# LINEAR
# first test, 11 is influential
hat_mat <- X2 %*% solve(t(X2) %*% X2) %*% t(X2)
yhatx2 <- X2 %*% BX2
errorest <- y - yhatx2
lev <- diag(hat_mat)
MSEX2 <- SSEX2 / (nrow(X2) - k)
stud_resid <- errorest / sqrt(as.numeric(MSEX2)) * sqrt(1 - lev)
id4 <- which.max(abs(stud_resid))
id4
abs(stud_resid)[id4] > crit
# 11 is true
#second test, 73 is influential
X2_rm11 <- X2[-11,]
hat_mat <- X2_rm11 %*% solve(t(X2_rm11) %*% X2_rm11) %*% t(X2_rm11)
yhatx2 <- X2_rm11 %*% BX2
errorest <- y[-11,] - yhatx2
lev <- diag(hat_mat)
MSEX2 <- SSEX2 / (nrow(X2_rm11) - k)
stud_resid <- errorest / sqrt(as.numeric(MSEX2)) * sqrt(1 - lev)
id5 <- which.max(abs(stud_resid))
id5
abs(stud_resid)[id5] > crit
#third test
inf <- c(11,73)
X2_rm_inf <- X2[-inf,]
hat_mat <- X2_rm_inf %*% solve(t(X2_rm_inf) %*% X2_rm_inf) %*% t(X2_rm_inf)
yhatx2 <- X2_rm_inf %*% BX2
errorest <- y[-inf] - yhatx2
lev <- diag(hat_mat)
MSEX2 <- SSEX2 / (nrow(X2_rm_inf) - k)
stud_resid <- errorest / sqrt(as.numeric(MSEX2)) * sqrt(1 - lev)
id6 <- which.max(abs(stud_resid))
id6
abs(stud_resid)[id6] > crit
library(MASS)
library(MASS)
library(tidyverse)
?Boston
library(MASS)
library(tidyverse)
# lets start by looking at medv by crim
ggplot(Boston, aes(x = crim, y = medv)) +
geom_point()
library(MASS)
library(tidyverse)
# lets start by looking at medv by crim
ggplot(Boston, aes(x = crim, y = medv)) +
geom_point()
# looks somewhat curved so lets include a quadratic term
# now, lets do medv by lstat
ggplot(Boston, aes(x = crim, y = lstat)) +
geom_point()
library(MASS)
library(tidyverse)
# lets start by looking at medv by crim
ggplot(Boston, aes(x = crim, y = medv)) +
geom_point()
# looks somewhat curved so lets include a quadratic term
# now, lets do medv by lstat
ggplot(Boston, aes(x = lstat, y = medv)) +
geom_point()
mod_max <- lm(medv ~ .*. + I(crim^2) + I(lstat^2), Boston)
mod_max <- lm(medv ~ .*. + I(crim^2) + I(lstat^2), Boston)
summar(mod_max)
mod_max <- lm(medv ~ .*. + I(crim^2) + I(lstat^2), Boston)
summary(mod_max)
mod_max <- lm(medv ~ .*. + I(crim^2) + I(lstat^2), Boston)
summary(mod_max)
# pvalues represent when its added to the model last,
# as in added when all other variables are added
mod_best <- step(mod_max, direction = "backward")
mod_best <- step(mod_max, direction = "backward", trace = 0)
mod_best <- step(mod_max, direction = "backward", trace = 0)
summary(mod_best)
mod_best <- step(mod_max, direction = "backward", trace = 1)
summary(mod_best)
# trace = 0 does not include the trace of the variables
# added benefit for step function, output is an lm object
mod_best <- step(mod_max, direction = "backward", trace = 0)
summary(mod_best)
# trace = 0 does not include the trace of the variables
# added benefit for step function, output is an lm object
mod_best <- step(mod_max, direction = "both", trace = 0)
mod_best <- step(mod_max, direction = "both", trace = 0)
summary(mod_best)
mod_best <- step(mod_max, direction = "backward", trace = 0)
mod_best1 <- step(mod_max, direction = "backward", trace = 0)
summary(mod_best)
# trace = 0 does not include the trace of the variables
# added benefit for step function, output is an lm object
mod_best1 <- step(mod_max, direction = "backward", trace = 0)
summary(mod_best1)
# trace = 0 does not include the trace of the variables
# added benefit for step function, output is an lm object
mod_best2 <- step(mod_max, direction = "both", trace = 0)
summary(mod_best2)
anova(mod_best1, mod_best2)
plot(mod_best1,1)
plot(mod_best1,2)
library(lmtest)
plot(mod_best1,1)
plot(mod_best1,2)
bptest(mod_best1)
library(lmtest)
plot(mod_best1,1)
plot(mod_best1,2)
bptest(mod_best1)
ks.test(mod_best1, "rstandard")
plot(mod_best1,1)
plot(mod_best1,2)
library(lmtest)
bptest(mod_best1)
ks.test(mod_best1, "rstandard")
plot(mod_best1,1)
plot(mod_best1,2)
library(lmtest)
bptest(mod_best1)
kstest(mod_best1, "rstandard")
plot(mod_best1,1)
plot(mod_best1,2)
library(lmtest)
bptest(mod_best1)
ks.test(rstandard(mod_best1), "pnorm")
plot(mod_best1,1)
plot(mod_best1,2)
library(lmtest)
bptest(mod_best1)
ks.test(rstandard(mod_best1), "pnorm")
newmod <- mod_best1[-372, ]
plot(mod_best1,1)
plot(mod_best1,2)
library(lmtest)
bptest(mod_best1)
ks.test(rstandard(mod_best1), "pnorm")
newmod <- mod_best1[-372]
anova(newmod, mod_best1)
plot(mod_best1,1)
plot(mod_best1,2)
library(lmtest)
bptest(mod_best1)
ks.test(rstandard(mod_best1), "pnorm")
newmod <- mod_best1[-372 , ]
plot(mod_best1,1)
plot(mod_best1,2)
library(lmtest)
bptest(mod_best1)
ks.test(rstandard(mod_best1), "pnorm")
newmod <- mod_best1[-372 , ]
mod_max_log <- lm(log(medv) ~ .*. + I(crim^2) + I(lstat^2), Boston)
mod_max_log <- lm(log(medv) ~ .*. + I(crim^2) + I(lstat^2), Boston)
mod_best_log <- step(mod_max_log, direction = 'both', trace = 0)
plot(mod_best_log,1)
plot(mod_best,log,2)
mod_max_log <- lm(log(medv) ~ .*. + I(crim^2) + I(lstat^2), Boston)
mod_best_log <- step(mod_max_log, direction = 'both', trace = 0)
plot(mod_best_log,1)
plot(mod_best_log,2)
plot(mod_best1,1)
plot(mod_best1,2)
library(lmtest)
bptest(mod_best1)
ks.test(rstandard(mod_best1), "pnorm")
anova(newmod, mod_best1)
plot(mod_best1,1)
plot(mod_best1,2)
library(lmtest)
bptest(mod_best1)
ks.test(rstandard(mod_best1), "pnorm")
# the leaps package contains multiple functions to perform variable selection by multiple different methods.
# specifically, the regsubsets() function
# bad news: does not directly output a linear model
library(leaps)
var_sel <- regsubsets(medv ~ .*. + I(crim^2) + I(lstat^2), Boston, method='seqrep', nvmax = 100, really.big = TRUE, trace = 0)
# the leaps package contains multiple functions to perform variable selection by multiple different methods.
# specifically, the regsubsets() function
# bad news: does not directly output a linear model
library(leaps)
var_sel <- regsubsets(medv ~ .*. + I(crim^2) + I(lstat^2), Boston, method='seqrep', nvmax = 100, really.big = TRUE)
# the leaps package contains multiple functions to perform variable selection by multiple different methods.
# specifically, the regsubsets() function
# bad news: does not directly output a linear model
library(leaps)
var_sel <- regsubsets(medv ~ .*. + I(crim^2) + I(lstat^2), Boston, method='seqrep', nvmax = 100, really.big = TRUE)
var_sel
# the leaps package contains multiple functions to perform variable selection by multiple different methods.
# specifically, the regsubsets() function
# bad news: does not directly output a linear model
library(leaps)
var_sel <- regsubsets(medv ~ .*. + I(crim^2) + I(lstat^2), Boston, method='seqrep', nvmax = 100, really.big = TRUE)
var_sel
# the leaps package contains multiple functions to perform variable selection by multiple different methods.
# specifically, the regsubsets() function
# bad news: does not directly output a linear model
library(leaps)
var_sel <- regsubsets(medv ~ .*. + I(crim^2) + I(lstat^2), Boston, method='seqrep', nvmax = 100, really.big = TRUE)
summary(var_sel)
# the leaps package contains multiple functions to perform variable selection by multiple different methods.
# specifically, the regsubsets() function
# bad news: does not directly output a linear model
library(leaps)
var_sel <- regsubsets(medv ~ .*. + I(crim^2) + I(lstat^2), Boston, method='seqrep', nvmax = 100, really.big = TRUE)
#summary(var_sel)
# summary shows which variables are included when we have only one variable model, 2 variable model, etc
summar(var_sel)$cp
# the leaps package contains multiple functions to perform variable selection by multiple different methods.
# specifically, the regsubsets() function
# bad news: does not directly output a linear model
library(leaps)
var_sel <- regsubsets(medv ~ .*. + I(crim^2) + I(lstat^2), Boston, method='seqrep', nvmax = 100, really.big = TRUE)
#summary(var_sel)
# summary shows which variables are included when we have only one variable model, 2 variable model, etc
summary(var_sel)$cp #mallows cp for the models with the given number of variables
summary(var_sel)$adjr2
# the leaps package contains multiple functions to perform variable selection by multiple different methods.
# specifically, the regsubsets() function
# bad news: does not directly output a linear model
library(leaps)
var_sel <- regsubsets(medv ~ .*. + I(crim^2) + I(lstat^2), Boston, method='seqrep', nvmax = 100, really.big = TRUE)
#summary(var_sel)
# summary shows which variables are included when we have only one variable model, 2 variable model, etc
summary(var_sel)$cp #mallows cp for the models with the given number of variables
summary(var_sel)$adjr2
which.min(summary(var_sel)$cp) #model that minimizes mallows cp
which.max(summary(var_sel)$adjrr2)
# the leaps package contains multiple functions to perform variable selection by multiple different methods.
# specifically, the regsubsets() function
# bad news: does not directly output a linear model
library(leaps)
var_sel <- regsubsets(medv ~ .*. + I(crim^2) + I(lstat^2), Boston, method='seqrep', nvmax = 100, really.big = TRUE)
#summary(var_sel)
# summary shows which variables are included when we have only one variable model, 2 variable model, etc
summary(var_sel)$cp #mallows cp for the models with the given number of variables
summary(var_sel)$adjr2
which.min(summary(var_sel)$cp) #model that minimizes mallows cp
which.max(summary(var_sel)$adjr2)
# the leaps package contains multiple functions to perform variable selection by multiple different methods.
# specifically, the regsubsets() function
# bad news: does not directly output a linear model
library(leaps)
var_sel <- regsubsets(medv ~ .*. + I(crim^2) + I(lstat^2), Boston, method='seqrep', nvmax = 100, really.big = TRUE)
#summary(var_sel)
# summary shows which variables are included when we have only one variable model, 2 variable model, etc
summary(var_sel)$cp #mallows cp for the models with the given number of variables
summary(var_sel)$adjr2
which.min(summary(var_sel)$cp) #model that minimizes mallows cp
which.max(summary(var_sel)$adjr2)
coef(var_sel,47)
# the leaps package contains multiple functions to perform variable selection by multiple different methods.
# specifically, the regsubsets() function
# bad news: does not directly output a linear model
library(leaps)
var_sel <- regsubsets(medv ~ .*. + I(crim^2) + I(lstat^2), Boston, method='seqrep', nvmax = 100, really.big = TRUE)
#summary(var_sel)
# summary shows which variables are included when we have only one variable model, 2 variable model, etc
summary(var_sel)$cp #mallows cp for the models with the given number of variables
summary(var_sel)$adjr2
which.min(summary(var_sel)$cp) #model that minimizes mallows cp
which.max(summary(var_sel)$adjr2)
coef(var_sel,47)
coef(var_sel, 53)
